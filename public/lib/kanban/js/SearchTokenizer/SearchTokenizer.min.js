/**
 * ---------------------------------------------------------------------
 *
 * GLPI - Gestionnaire Libre de Parc Informatique
 *
 * http://glpi-project.org
 *
 * @copyright 2015-2024 Teclib' and contributors.
 * @copyright 2003-2014 by the INDEPNET Development Team.
 * @licence   https://www.gnu.org/licenses/gpl-3.0.html
 *
 * ---------------------------------------------------------------------
 *
 * LICENSE
 *
 * This file is part of GLPI.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * ---------------------------------------------------------------------
 */
import SearchToken from"./SearchToken.js";import SearchTokenizerResult from"./SearchTokenizerResult.js";export default class SearchTokenizer{constructor(e={},t=false,s={}){this.token_pattern=/([^\s"']?\w+:)?("[^"]*"|'[^']*'|[^\s]+)/g;this.EXCLUSION_PREFIX="!";this.allowed_tags=e;this.drop_unallowed_tags=t;this.options=Object.assign({custom_prefixes:{}},s);delete this.options.custom_prefixes[this.EXCLUSION_PREFIX];delete this.options.custom_prefixes["'"];delete this.options.custom_prefixes['"']}isAllowedTag(e){if(e===null||e===undefined){return true}const t=Object.keys(this.allowed_tags).length===0||e in this.allowed_tags;return t}clearAutocomplete(){Object.keys(this.allowed_tags).forEach((e=>{this.allowed_tags[e].autocomplete_values=[]}))}setAutocomplete(e,t){if(e in this.allowed_tags){this.allowed_tags[e].autocomplete_values=t}}getAutocomplete(e){let t=[];if(e in this.allowed_tags){if(typeof this.allowed_tags[e].autocomplete_values==="function"){t=this.allowed_tags[e].autocomplete_values()}else{t=this.allowed_tags[e].autocomplete_values}}return t||[]}tokenize(e){e=e||"";e=e.trim();const t=new SearchTokenizerResult;let s=null;let l=0;while((s=this.token_pattern.exec(e))!==null){let e=false;let i=s[1]||null;let o=s[2].trim();if(i){i=i.slice(0,-1)}if(i===null&&o.endsWith(":")){i=o.slice(0,-1);o=""}let a=null;if(i&&i.length>1){const t=i.slice(0,1);const s=Object.keys(this.options.custom_prefixes);if(t===this.EXCLUSION_PREFIX){e=true;i=i.slice(1)}else{if(s.includes(t)){const e=i.slice(1);if(this.allowed_tags[e]&&this.allowed_tags[e].supported_prefixes.includes(t)){a=t;i=e}}}}if(!this.allowed_tags[i]||!(this.allowed_tags[i].supported_prefixes||[]).includes(this.EXCLUSION_PREFIX)){e=false}o=o||"";if(o.length>0){if(/^".+"$/.test(o)){o=o.trim().replace(/^"/,"").replace(/"$/,"").trim()}if(/^'.+'$/.test(o)){o=o.trim().replace(/^'/,"").replace(/'$/,"").trim()}}if(this.isAllowedTag(i)){t.tokens.push(new SearchToken(o,i,e,l++,s[0],a))}else if(!this.drop_unallowed_tags){t.tokens.push(new SearchToken(s[0],null,false,l++,s[0]))}}return t}}